<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Mini GTA-like Driving Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body{height:100%;margin:0;overflow:hidden;background:#111}
    #overlay{
      position:fixed;left:10px;top:10px;color:#fff;font-family:Arial,Helvetica,sans-serif;
      z-index:20;background:rgba(0,0,0,0.45);padding:10px;border-radius:8px;
      min-width:160px;
    }
    #centerMsg{
      position:fixed;left:50%;top:10%;transform:translateX(-50%);color:#fff;
      z-index:20;font-family:Arial,Helvetica,sans-serif;background:rgba(0,0,0,0.6);
      padding:12px;border-radius:8px;
    }
    button{padding:8px 12px;border-radius:6px;border:0;background:#28a; color:white}
    canvas{display:block}
    #instructions{font-size:13px;line-height:1.4}
    #hud{position:fixed;right:12px;top:10px;color:#fff;font-family:monospace;background:rgba(0,0,0,0.35);padding:8px;border-radius:6px}
  </style>
</head>
<body>
<div id="overlay">
  <div style="font-weight:bold;margin-bottom:6px">Mini GTA-like Driving Demo</div>
  <div id="instructions">
    Click <b>Play</b> then click inside canvas to lock mouse.<br>
    WASD = walk / drive, Shift = run, Space = jump (walking only),<br>
    E = enter/exit nearest vehicle, LMB = shoot (not implemented yet).<br>
    Esc = release mouse.
  </div>
  <div style="margin-top:8px">
    <button id="playBtn">Play</button>
    <button id="resetBtn">Reset</button>
  </div>
</div>
<div id="centerMsg" style="display:none"></div>
<div id="hud">Mode: <span id="mode">On Foot</span><br>Speed: <span id="speed">0</span> km/h<br>Health: <span id="health">100</span></div>

<script src="https://unpkg.com/three@0.154.0/build/three.min.js"></script>
<script>
/*
  Upgraded mini GTA-like demo with multiple cars and improved driving physics.
  - Player can walk around, enter/exit nearest car.
  - Driving includes acceleration, braking, steering with inertia.
  - Smooth camera transitions and HUD updates.
*/

let scene, camera, renderer, clock;
let player, cars = [], npc, ground;
let keys = {};
let pointerLocked = false;
let velocity = new THREE.Vector3();
let cameraPitch = 0, cameraYaw = 0;
let canJump = true;
let onGround = true;
let inVehicle = false;
let currentCar = null;
let health = 100;
let speed = 0;
const GRAVITY = 30;
const WALK_SPEED = 6;
const RUN_SPEED = 12;
const JUMP_VEL = 10;
const MAX_SPEED_KMH = 120; // max car speed
const KMH_TO_MPS = 1000/3600; // conversion factor

const raycaster = new THREE.Raycaster();
let messages = document.getElementById('centerMsg');
let hudMode = null, hudSpeed = null, hudHealth = null;

init();
animate();

function init(){
  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb);
  camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);

  clock = new THREE.Clock();

  const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
  hemi.position.set(0,200,0);
  scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 0.8);
  dir.position.set(-50,80,60);
  scene.add(dir);

  // ground
  const groundMat = new THREE.MeshStandardMaterial({color:0x3a712b});
  const groundGeo = new THREE.PlaneGeometry(400,400);
  ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI/2;
  ground.receiveShadow = true;
  scene.add(ground);

  // environment boxes
  const boxGeo = new THREE.BoxGeometry(8,8,8);
  const boxMat = new THREE.MeshStandardMaterial({color:0x666666});
  for(let i=0;i<60;i++){
    const b = new THREE.Mesh(boxGeo, boxMat);
    b.position.set((Math.random()-0.5)*200,4,(Math.random()-0.5)*200);
    b.scale.y = 1 + Math.random()*4;
    scene.add(b);
  }

  // player object
  player = new THREE.Object3D();
  player.position.set(0,2,8);
  scene.add(player);
  camera.position.set(0,1.6,0);
  player.add(camera);

  // create cars (multiple)
  createCar(new THREE.Vector3(4,0.6,6), 0x0055ff, 1.0);    // compact car
  createCar(new THREE.Vector3(-12,0.6,-8), 0xff5500, 1.2); // bigger car
  createCar(new THREE.Vector3(15,0.6,-10), 0x22aa22, 0.9);  // smaller car

  // HUD refs
  hudMode = document.getElementById('mode');
  hudSpeed = document.getElementById('speed');
  hudHealth = document.getElementById('health');
  updateHUD();

  window.addEventListener('resize', onWindowResize);
  document.addEventListener('keydown', (e)=>{ keys[e.code]=true; });
  document.addEventListener('keyup', (e)=>{ keys[e.code]=false; });
  renderer.domElement.addEventListener('click', onCanvasClick);
  document.addEventListener('pointerlockchange', onPointerLockChange);
  document.addEventListener('mousemove', onMouseMove);

  document.getElementById('playBtn').addEventListener('click', ()=>{  
    messages.style.display='none';
    startGame();
  });
  document.getElementById('resetBtn').addEventListener('click', ()=>{ resetGame(); });

  showMessage('Press Play then click the game area to lock mouse', 6);
}

function createCar(pos, color, scale){
  const carGeo = new THREE.BoxGeometry(2.6,1,4);
  const carMat = new THREE.MeshStandardMaterial({color:color});
  const car = new THREE.Mesh(carGeo, carMat);
  car.position.copy(pos);
  car.scale.setScalar(scale);
  car.userData = {
    speed:0,
    acceleration:0,
    steering:0,
    maxSpeed: 120 * KMH_TO_MPS,
    maxReverseSpeed: -30 * KMH_TO_MPS,
    maxAcceleration: 8,
    maxBrake: 15,
    maxSteering: 0.5,
    driver: null
  };
  scene.add(car);
  cars.push(car);
}

function startGame(){
  renderer.domElement.requestPointerLock();
  health = 100;
  updateHUD();
}

function onCanvasClick(){
  if(document.pointerLockElement === renderer.domElement) return;
  renderer.domElement.requestPointerLock();
}

function onPointerLockChange(){
  pointerLocked = (document.pointerLockElement === renderer.domElement);
}

function onMouseMove(e){
  if(!pointerLocked) return;
  const movementX = e.movementX || 0;
  const movementY = e.movementY || 0;
  cameraYaw -= movementX * 0.0022;
  cameraPitch -= movementY * 0.0022;
  cameraPitch = Math.max(-Math.PI/2+0.1, Math.min(Math.PI/2-0.1, cameraPitch));
  player.rotation.y = cameraYaw;
  camera.rotation.x = cameraPitch;
}

function animate(){
  requestAnimationFrame(animate);
  const dt = Math.min(0.05, clock.getDelta());
  update(dt);
  renderer.render(scene, camera);
}

function update(dt){
  if(inVehicle){
    updateVehicle(dt);
  } else {
    updatePlayerMovement(dt);
  }
  if(player.position.y < -10){
    resetPlayer();
  }
}

function updatePlayerMovement(dt){
  let forward = new THREE.Vector3(0,0,-1).applyQuaternion(player.quaternion);
  forward.y = 0; forward.normalize();
  let right = new THREE.Vector3(1,0,0).applyQuaternion(player.quaternion);
  right.y=0; right.normalize();

  let speed = keys['ShiftLeft'] ? RUN_SPEED : WALK_SPEED;
  let move = new THREE.Vector3();
  if(keys['KeyW']) move.add(forward);
  if(keys['KeyS']) move.add(forward.clone().negate());
  if(keys['KeyA']) move.add(right.clone().negate());
  if(keys['KeyD']) move.add(right);

  if(move.length() > 0){
    move.normalize();
    velocity.x = move.x * speed;
    velocity.z = move.z * speed;
  } else {
    velocity.x = THREE.MathUtils.lerp(velocity.x, 0, dt*8);
    velocity.z = THREE.MathUtils.lerp(velocity.z, 0, dt*8);
  }

  // gravity & jumping (very simple)
  if(onGround && keys['Space']){
    velocity.y = JUMP_VEL;
    onGround = false;
  } else if(!onGround){
    velocity.y -= GRAVITY * dt;
  }

  player.position.addScaledVector(velocity, dt);

  if(player.position.y <= 2){
    player.position.y = 2;
    velocity.y = 0;
    onGround = true;
  }

  // try enter vehicle
  if(keys['KeyE']){
    if(tryEnterNearestCar()){
      keys['KeyE'] = false;
    }
  }
}

function tryEnterNearestCar(){
  if(inVehicle) return false;
  let nearest = null;
  let nearestDist = 9999;
  for(let car of cars){
    if(car.userData.driver !== null) continue; // taken
    let dist = player.position.distanceTo(car.position);
    if(dist < 3.2 && dist < nearestDist){
      nearest = car;
      nearestDist = dist;
    }
  }
  if(nearest){
    enterVehicle(nearest);
    return true;
  }
  return false;
}

function enterVehicle(car){
  inVehicle = true;
  currentCar = car;
  car.userData.driver = player;
  // attach camera to car
  car.add(camera);
  camera.position.set(0,1.1,-3.6);
  camera.rotation.set(0,0,0);
  hudMode.innerText = 'Driving';
  showMessage('Entered vehicle. WASD to drive, E to exit.', 3);
}

function exitVehicle(){
  if(!inVehicle) return;
  inVehicle = false;
  if(currentCar){
    currentCar.userData.driver = null;
    scene.add(camera);
    camera.position.set(0,1.6,0);
    player.add(camera);
    // place player next to car
    let offset = new THREE.Vector3(2,0,0).applyQuaternion(currentCar.quaternion);
    player.position.copy(currentCar.position).add(offset);
    currentCar = null;
  }
  hudMode.innerText = 'On Foot';
  hudSpeed.innerText = '0';
  showMessage('Exited vehicle.', 2);
}

function updateVehicle(dt){
  if(!currentCar) return;
  const car = currentCar;
  const ud = car.userData;

  // Acceleration/braking input
  if(keys['KeyW']){
    ud.acceleration = ud.maxAcceleration;
  } else if(keys['KeyS']){
    ud.acceleration = -ud.maxBrake;
  } else {
    ud.acceleration = 0;
  }

  // Steering input (only if moving)
  if(ud.speed > 0.5 || ud.speed < -0.5){
    if(keys['KeyA']){
      ud.steering = Math.min(ud.steering + 0.05, ud.maxSteering);
    } else if(keys['KeyD']){
      ud.steering = Math.max(ud.steering - 0.05, -ud.maxSteering);
    } else {
      // return steering to 0 gradually
      if(ud.steering > 0) ud.steering = Math.max(0, ud.steering - 0.04);
      else if(ud.steering < 0) ud.steering = Math.min(0, ud.steering + 0.04);
    }
  } else {
    ud.steering = 0;
  }

  // Update speed with acceleration
  ud.speed += ud.acceleration * dt;
  if(ud.speed > ud.maxSpeed) ud.speed = ud.maxSpeed;
  if(ud.speed < ud.maxReverseSpeed) ud.speed = ud.maxReverseSpeed;

  // Apply friction if no acceleration
  if(ud.acceleration === 0){
    if(ud.speed > 0){
      ud.speed = Math.max(0, ud.speed - ud.maxBrake * dt * 0.4);
    } else if(ud.speed < 0){
      ud.speed = Math.min(0, ud.speed + ud.maxBrake * dt * 0.4);
    }
  }

  // Move car forward
  let forward = new THREE.Vector3(0,0,-1).applyQuaternion(car.quaternion);
  car.position.addScaledVector(forward, ud.speed * dt);

  // Apply steering to rotation (turning)
  let turnRadius = 5; // smaller radius = sharper turn
  if(ud.steering !== 0){
    let angularVelocity = ud.speed / turnRadius * ud.steering;
    car.rotation.y += angularVelocity * dt;
  }

  // Update speed for HUD in km/h
  hudSpeed.innerText = Math.round(ud.speed / KMH_TO_MPS);

  // Exit vehicle with E
  if(keys['KeyE']){
    exitVehicle();
    keys['KeyE'] = false;
  }
}

function resetPlayer(){
  player.position.set(0,2,8);
  velocity.set(0,0,0);
  cameraPitch = 0; cameraYaw = 0;
  player.rotation.set(0,0,0);
  updateHUD();
}

function resetGame(){
  // Reset player and cars
  resetPlayer();
  for(let i=0; i<cars.length; i++){
    let c = cars[i];
    // Reset positions (hardcoded for demo)
    if(i===0) c.position.set(4,0.6,6);
    else if(i===1) c.position.set(-12,0.6,-8);
    else if(i===2) c.position.set(15,0.6,-10);
    c.userData.speed = 0;
    c.userData.acceleration = 0;
    c.userData.steering = 0;
    c.userData.driver = null;
  }
  if(inVehicle) exitVehicle();
  health = 100;
  hudHealth.innerText = health;
  showMessage('Game reset', 1);
}

function updateHUD(){
  hudHealth.innerText = health;
}

function showMessage(text, seconds=2){
  messages.style.display = 'block';
  messages.innerText = text;
  if(seconds>0){
    setTimeout(()=>{ messages.style.display='none'; }, seconds*1000);
  }
}

function onWindowResize(){
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

</script>
</body>
</html>
